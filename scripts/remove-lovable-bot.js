/* Usage:   From repo root:     node scripts/remove-lovable-bot.js*/import fs from "node:fs";import path from "node:path";import { fileURLToPath, pathToFileURL } from "node:url";const __filename = fileURLToPath(import.meta.url);const __dirname = path.dirname(__filename);const ROOT = path.resolve(__dirname, "..");const SKIP_DIRS = new Set([  ".git",  "node_modules",  "dist",  "build",  "coverage",  ".next",  ".turbo",  ".expo",  ".cache",  "out",]);const BINARY_EXTS = new Set([  ".png",  ".jpg",  ".jpeg",  ".gif",  ".webp",  ".ico",  ".svgz",  ".zip",  ".gz",  ".tgz",  ".bz2",  ".7z",  ".pdf",  ".doc",  ".docx",  ".xls",  ".xlsx",  ".ppt",  ".pptx",  ".mp3",  ".ogg",  ".wav",  ".mp4",  ".mov",  ".avi",  ".mkv",  ".ttf",  ".otf",  ".eot",  ".woff",  ".woff2",  ".jar",  ".exe",  ".dll",  ".bin",]);// Patterns to removeconst BOT_PATTERNS = [/@?lovable-dev\[bot\]/gi];// NEW: inline removals for Lovable markup (safe attribute-level removal)const INLINE_PATTERNS = [  // Remove HTML/JSX attributes like data-lovable-id="..." or data-lovable-...={...}  { re: /\sdata-lovable-[a-z-]+="[^"]*"/gi },  { re: /\sdata-lovable-[a-z-]+=\{[^}]*\}/gi },];// Lines to drop entirely if they reference the botconst DROP_LINE_PATTERNS = [  /co-authored-by:.*@?lovable-dev\[bot\]/i,  /signed-off-by:.*@?lovable-dev\[bot\]/i,  // NEW: drop Lovable Vite plugin traces  /import\s+.*componentTagger.*from.*/i,  /componentTagger\s*\([^)]*\)/i,  /lovable-?tagger/i,];function shouldSkipDir(dirName) {  return SKIP_DIRS.has(dirName);}function isBinaryByExt(filePath) {  const ext = path.extname(filePath).toLowerCase();  return BINARY_EXTS.has(ext);}function detectNewline(text) {  return text.includes("\r\n") ? "\r\n" : "\n";}function cleanContent(filePath, content) {  const original = content;  const newline = detectNewline(content);  // Replace inline mentions  BOT_PATTERNS.forEach((re) => {    content = content.replace(re, "");  });  // NEW: apply inline Lovable attribute removals  INLINE_PATTERNS.forEach(({ re }) => {    content = content.replace(re, "");  });  // Drop lines that were bot attributions and collapse excess blank lines  const lines = content.split(/\r?\n/);  const cleanedLines = [];  for (let i = 0; i < lines.length; i++) {    const origLine = original.split(/\r?\n/)[i] ?? lines[i];    const line = lines[i];    const shouldDrop = DROP_LINE_PATTERNS.some((re) => re.test(origLine));    if (shouldDrop) continue;    cleanedLines.push(line);  }  // Normalize multiple blank lines to a single blank line  const collapsed = [];  let blankStreak = 0;  for (const l of cleanedLines) {    if (l.trim() === "") {      blankStreak += 1;      if (blankStreak > 1) continue;    } else {      blankStreak = 0;    }    collapsed.push(l);  }  const result = collapsed.join(newline);  return result;}function walk(dir) {  const entries = fs.readdirSync(dir, { withFileTypes: true });  const files = [];  for (const ent of entries) {    if (ent.isDirectory()) {      if (shouldSkipDir(ent.name)) continue;      files.push(...walk(path.join(dir, ent.name)));    } else if (ent.isFile()) {      files.push(path.join(dir, ent.name));    }  }  return files;}function run() {  const files = walk(ROOT);  let changedCount = 0;  for (const file of files) {    if (isBinaryByExt(file)) continue;    let content;    try {      content = fs.readFileSync(file, "utf8");    } catch {      continue; // skip unreadable files    }    if (      !/@?lovable-dev\[bot\]/i.test(content) &&      !/co-authored-by:.*lovable-dev\[bot\]/i.test(content) &&      !/signed-off-by:.*lovable-dev\[bot\]/i.test(content) &&      // NEW: quick scan for Lovable attributes or plugin traces      !/data-lovable-|componentTagger|lovable-?tagger/i.test(content)    ) {
      continue; // fast skip
    }

    const cleaned = cleanContent(file, content);
    if (cleaned !== content) {
      fs.writeFileSync(file, cleaned, "utf8");
      changedCount++;
      console.log(`Cleaned: ${path.relative(ROOT, file)}`);
    }
  }

  console.log(`Done. Files changed: ${changedCount}`);
}

if (import.meta.url === pathToFileURL(process.argv[1]).href) {
  run();
}
